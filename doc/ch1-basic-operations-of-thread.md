# 线程启动、结束，创建线程的方法
[toc]

## 范例演示线程运行的开始和结束
1. 程序运行起来，生成一个进行，该进程所属的主线程开始自动运行
2. 由于主线程从 main() 开始运行，那么手动创建的线程也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，该线程就结束了
  整个程序是否执行完毕的标志是主线程是否结束，如果主线程结束了，那么整个程序就结束了。
  此时，如果其他子线程还没有执行完毕，那么这些子线程也会被操作系统强制结束。
  所以，如果我们需要等待子线程执行完毕，那么我们需要在主线程中等待子线程结束，这样就可以保证主线程不会结束，从而保证整个程序不会结束。

手动创建线程的步骤：
> 1. 包含头文件： `#include <thread>`
> 2. 定义初始函数 `myPrint`
> 3. 创建线程对象 `std::thread t1(myPrint);`
> 4. 等待线程结束 `t1.join();`


### `join()` 函数
`join()` 函数的作用是等待线程结束，如果线程已经结束了，那么 `join()` 函数会立即返回，否则，`join()` 函数会**阻塞**当前线程，直到目标线程结束。

### `detach()` 函数
`detach()` 函数的作用是分离线程。子线程与主线程不会和，主线程结束后，子线程也会继续执行。一旦调用了 `detach()` 函数，主线程与该子线程就失去了联系，子线程会驻留在后台运行，那么就不能再调用 `join()` 函数了。
当这个子线程执行完毕，有运行时库负责清理子线程相关的资源。

### `joinable()` 函数
`joinable()` 函数的作用是判断线程是否可以被 `join()` 和 `detach()` 函数调用。如果线程可以被 `join()` 函数调用，那么 `joinable()` 函数返回 `true`，否则返回 `false`。

## 其他创建线程的方法
### 1. 通过类的成员函数创建线程
```cpp
class MyThread {
 public:
  void operator()() { //不能带参数
    for (int i = 0; i < 100; i++) {
        std::cout << "子线程执行，i = " << i << std::endl;
      }
    }
};

// in main()
MyThread myThread;
std::thread t1(myThread); // 通过类的成员函数创建线程，此时传入的参数是通过拷贝构造函数传入的，即便主线程结束，myThread被销毁，子线程中的对象依然有效 (1)
```

**在(1)处调用了几次拷贝构造函数？**
GCC的实现是拷贝了两次.
看了6.3.0源码,thread里拷贝了两次。第一次构造bind,这里msvc和gcc都是需要一次拷贝，区别是msvc直接make_unique tuple去invoke，gcc是先构造一个bind,再把bind移动到unique_ptr里。
GCC中如果类没有移动构造，那么会发生两次copy。
总的来说，(1)处的流程为：
1. 调用默认构造函数构造对象 `myThread`
2. 实现绑定：调用拷贝构造函数构造对象 `myThread` 的拷贝，为临时对象。对msvc和gcc，此处相同。
3. 将bind移动到 `unique_ptr`，对msvc，直接 `make_unique`，对gcc，先构造 `unique_ptr`，再移动。

### 2. 通过 Lambda 表达式创建线程
```cpp
// in main()
std::thread t1([]() {
  for (int i = 0; i < 100; i++) {
    std::cout << "子线程执行，i = " << i << std::endl;
  }
});
```